// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package hand

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// HandServiceClient is the client API for HandService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HandServiceClient interface {
	// CreateHand registers a hand to DB.
	// If the player_id is not found in DB, returns invalid argument error.
	CreateHand(ctx context.Context, in *CreateHandRequest, opts ...grpc.CallOption) (*CreateHandResponse, error)
	// FetchHands fetches all HandSummaries.
	// If hands is not in DB, returns empty array.
	FetchHands(ctx context.Context, in *FetchHandsRequest, opts ...grpc.CallOption) (*FetchHandsResponse, error)
	// FetchHandScore fetches a hand by hand's ID.
	// If hand's ID is not in DB, return not found error.
	FetchHandScore(ctx context.Context, in *FetchHandScoreRequest, opts ...grpc.CallOption) (*FetchHandScoreResponse, error)
	// UpdateHandScores updates scores of a hand.
	// If there is no hand ID in DB, return a not found error.
	// If scores are invalid, return a invalid argument error.
	UpdateHandScores(ctx context.Context, in *UpdateHandScoresRequest, opts ...grpc.CallOption) (*UpdateHandScoresResponse, error)
}

type handServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHandServiceClient(cc grpc.ClientConnInterface) HandServiceClient {
	return &handServiceClient{cc}
}

func (c *handServiceClient) CreateHand(ctx context.Context, in *CreateHandRequest, opts ...grpc.CallOption) (*CreateHandResponse, error) {
	out := new(CreateHandResponse)
	err := c.cc.Invoke(ctx, "/app.services.hand.v1.HandService/CreateHand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *handServiceClient) FetchHands(ctx context.Context, in *FetchHandsRequest, opts ...grpc.CallOption) (*FetchHandsResponse, error) {
	out := new(FetchHandsResponse)
	err := c.cc.Invoke(ctx, "/app.services.hand.v1.HandService/FetchHands", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *handServiceClient) FetchHandScore(ctx context.Context, in *FetchHandScoreRequest, opts ...grpc.CallOption) (*FetchHandScoreResponse, error) {
	out := new(FetchHandScoreResponse)
	err := c.cc.Invoke(ctx, "/app.services.hand.v1.HandService/FetchHandScore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *handServiceClient) UpdateHandScores(ctx context.Context, in *UpdateHandScoresRequest, opts ...grpc.CallOption) (*UpdateHandScoresResponse, error) {
	out := new(UpdateHandScoresResponse)
	err := c.cc.Invoke(ctx, "/app.services.hand.v1.HandService/UpdateHandScores", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HandServiceServer is the server API for HandService service.
// All implementations should embed UnimplementedHandServiceServer
// for forward compatibility
type HandServiceServer interface {
	// CreateHand registers a hand to DB.
	// If the player_id is not found in DB, returns invalid argument error.
	CreateHand(context.Context, *CreateHandRequest) (*CreateHandResponse, error)
	// FetchHands fetches all HandSummaries.
	// If hands is not in DB, returns empty array.
	FetchHands(context.Context, *FetchHandsRequest) (*FetchHandsResponse, error)
	// FetchHandScore fetches a hand by hand's ID.
	// If hand's ID is not in DB, return not found error.
	FetchHandScore(context.Context, *FetchHandScoreRequest) (*FetchHandScoreResponse, error)
	// UpdateHandScores updates scores of a hand.
	// If there is no hand ID in DB, return a not found error.
	// If scores are invalid, return a invalid argument error.
	UpdateHandScores(context.Context, *UpdateHandScoresRequest) (*UpdateHandScoresResponse, error)
}

// UnimplementedHandServiceServer should be embedded to have forward compatible implementations.
type UnimplementedHandServiceServer struct {
}

func (UnimplementedHandServiceServer) CreateHand(context.Context, *CreateHandRequest) (*CreateHandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateHand not implemented")
}
func (UnimplementedHandServiceServer) FetchHands(context.Context, *FetchHandsRequest) (*FetchHandsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchHands not implemented")
}
func (UnimplementedHandServiceServer) FetchHandScore(context.Context, *FetchHandScoreRequest) (*FetchHandScoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchHandScore not implemented")
}
func (UnimplementedHandServiceServer) UpdateHandScores(context.Context, *UpdateHandScoresRequest) (*UpdateHandScoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHandScores not implemented")
}

// UnsafeHandServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HandServiceServer will
// result in compilation errors.
type UnsafeHandServiceServer interface {
	mustEmbedUnimplementedHandServiceServer()
}

func RegisterHandServiceServer(s grpc.ServiceRegistrar, srv HandServiceServer) {
	s.RegisterService(&HandService_ServiceDesc, srv)
}

func _HandService_CreateHand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateHandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HandServiceServer).CreateHand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.services.hand.v1.HandService/CreateHand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HandServiceServer).CreateHand(ctx, req.(*CreateHandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HandService_FetchHands_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchHandsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HandServiceServer).FetchHands(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.services.hand.v1.HandService/FetchHands",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HandServiceServer).FetchHands(ctx, req.(*FetchHandsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HandService_FetchHandScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchHandScoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HandServiceServer).FetchHandScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.services.hand.v1.HandService/FetchHandScore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HandServiceServer).FetchHandScore(ctx, req.(*FetchHandScoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HandService_UpdateHandScores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHandScoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HandServiceServer).UpdateHandScores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/app.services.hand.v1.HandService/UpdateHandScores",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HandServiceServer).UpdateHandScores(ctx, req.(*UpdateHandScoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HandService_ServiceDesc is the grpc.ServiceDesc for HandService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HandService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "app.services.hand.v1.HandService",
	HandlerType: (*HandServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateHand",
			Handler:    _HandService_CreateHand_Handler,
		},
		{
			MethodName: "FetchHands",
			Handler:    _HandService_FetchHands_Handler,
		},
		{
			MethodName: "FetchHandScore",
			Handler:    _HandService_FetchHandScore_Handler,
		},
		{
			MethodName: "UpdateHandScores",
			Handler:    _HandService_UpdateHandScores_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/services/hand/v1/service.proto",
}
